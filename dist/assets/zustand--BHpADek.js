import{r as R,o as j}from"./react-CxzTU07i.js";import{b as T}from"./@improbable-eng-BU3rlaSz.js";var z={VITE_APP_ENV:"testnet",BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const b=e=>{let r;const n=new Set,s=(h,y)=>{const p=typeof h=="function"?h(r):h;if(!Object.is(p,r)){const l=r;r=y??(typeof p!="object"||p===null)?p:Object.assign({},r,p),n.forEach(v=>v(r,l))}},o=()=>r,S={setState:s,getState:o,getInitialState:()=>c,subscribe:h=>(n.add(h),()=>n.delete(h)),destroy:()=>{(z?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),n.clear()}},c=r=e(s,o,S);return S},F=e=>e?b(e):b;var P={exports:{}},O={},A={exports:{}},H={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var E=R;function L(e,r){return e===r&&(e!==0||1/e===1/r)||e!==e&&r!==r}var N=typeof Object.is=="function"?Object.is:L,C=E.useState,U=E.useEffect,k=E.useLayoutEffect,J=E.useDebugValue;function W(e,r){var n=r(),s=C({inst:{value:n,getSnapshot:r}}),o=s[0].inst,t=s[1];return k(function(){o.value=n,o.getSnapshot=r,w(o)&&t({inst:o})},[e,n,r]),U(function(){return w(o)&&t({inst:o}),e(function(){w(o)&&t({inst:o})})},[e]),J(n),n}function w(e){var r=e.getSnapshot;e=e.value;try{var n=r();return!N(e,n)}catch{return!0}}function q(e,r){return r()}var B=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?q:W;H.useSyncExternalStore=E.useSyncExternalStore!==void 0?E.useSyncExternalStore:B;A.exports=H;var M=A.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var I=R,V=M;function G(e,r){return e===r&&(e!==0||1/e===1/r)||e!==e&&r!==r}var K=typeof Object.is=="function"?Object.is:G,Q=V.useSyncExternalStore,X=I.useRef,Y=I.useEffect,Z=I.useMemo,ee=I.useDebugValue;O.useSyncExternalStoreWithSelector=function(e,r,n,s,o){var t=X(null);if(t.current===null){var d={hasValue:!1,value:null};t.current=d}else d=t.current;t=Z(function(){function S(l){if(!c){if(c=!0,h=l,l=s(l),o!==void 0&&d.hasValue){var v=d.value;if(o(v,l))return y=v}return y=l}if(v=y,K(h,l))return v;var u=s(l);return o!==void 0&&o(v,u)?v:(h=l,y=u)}var c=!1,h,y,p=n===void 0?null:n;return[function(){return S(r())},p===null?void 0:function(){return S(p())}]},[r,n,s,o]);var f=Q(e,t[0],t[1]);return Y(function(){d.hasValue=!0,d.value=f},[f]),ee(f),f};P.exports=O;var te=P.exports;const re=T(te);var $={VITE_APP_ENV:"testnet",BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const{useDebugValue:ne}=j,{useSyncExternalStoreWithSelector:oe}=re;let x=!1;const se=e=>e;function ie(e,r=se,n){($?"production":void 0)!=="production"&&n&&!x&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),x=!0);const s=oe(e.subscribe,e.getState,e.getServerState||e.getInitialState,r,n);return ne(s),s}const D=e=>{($?"production":void 0)!=="production"&&typeof e!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const r=typeof e=="function"?F(e):e,n=(s,o)=>ie(r,s,o);return Object.assign(n,r),n},me=e=>e?D(e):D;var ae={VITE_APP_ENV:"testnet",BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};function ue(e,r){let n;try{n=e()}catch{return}return{getItem:o=>{var t;const d=S=>S===null?null:JSON.parse(S,void 0),f=(t=n.getItem(o))!=null?t:null;return f instanceof Promise?f.then(d):d(f)},setItem:(o,t)=>n.setItem(o,JSON.stringify(t,void 0)),removeItem:o=>n.removeItem(o)}}const _=e=>r=>{try{const n=e(r);return n instanceof Promise?n:{then(s){return _(s)(n)},catch(s){return this}}}catch(n){return{then(s){return this},catch(s){return _(s)(n)}}}},ce=(e,r)=>(n,s,o)=>{let t={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:a=>a,version:0,merge:(a,m)=>({...m,...a}),...r},d=!1;const f=new Set,S=new Set;let c;try{c=t.getStorage()}catch{}if(!c)return e((...a)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),n(...a)},s,o);const h=_(t.serialize),y=()=>{const a=t.partialize({...s()});let m;const i=h({state:a,version:t.version}).then(g=>c.setItem(t.name,g)).catch(g=>{m=g});if(m)throw m;return i},p=o.setState;o.setState=(a,m)=>{p(a,m),y()};const l=e((...a)=>{n(...a),y()},s,o);let v;const u=()=>{var a;if(!c)return;d=!1,f.forEach(i=>i(s()));const m=((a=t.onRehydrateStorage)==null?void 0:a.call(t,s()))||void 0;return _(c.getItem.bind(c))(t.name).then(i=>{if(i)return t.deserialize(i)}).then(i=>{if(i)if(typeof i.version=="number"&&i.version!==t.version){if(t.migrate)return t.migrate(i.state,i.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return i.state}).then(i=>{var g;return v=t.merge(i,(g=s())!=null?g:l),n(v,!0),y()}).then(()=>{m==null||m(v,void 0),d=!0,S.forEach(i=>i(v))}).catch(i=>{m==null||m(void 0,i)})};return o.persist={setOptions:a=>{t={...t,...a},a.getStorage&&(c=a.getStorage())},clearStorage:()=>{c==null||c.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>u(),hasHydrated:()=>d,onHydrate:a=>(f.add(a),()=>{f.delete(a)}),onFinishHydration:a=>(S.add(a),()=>{S.delete(a)})},u(),v||l},le=(e,r)=>(n,s,o)=>{let t={storage:ue(()=>localStorage),partialize:u=>u,version:0,merge:(u,a)=>({...a,...u}),...r},d=!1;const f=new Set,S=new Set;let c=t.storage;if(!c)return e((...u)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),n(...u)},s,o);const h=()=>{const u=t.partialize({...s()});return c.setItem(t.name,{state:u,version:t.version})},y=o.setState;o.setState=(u,a)=>{y(u,a),h()};const p=e((...u)=>{n(...u),h()},s,o);o.getInitialState=()=>p;let l;const v=()=>{var u,a;if(!c)return;d=!1,f.forEach(i=>{var g;return i((g=s())!=null?g:p)});const m=((a=t.onRehydrateStorage)==null?void 0:a.call(t,(u=s())!=null?u:p))||void 0;return _(c.getItem.bind(c))(t.name).then(i=>{if(i)if(typeof i.version=="number"&&i.version!==t.version){if(t.migrate)return t.migrate(i.state,i.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return i.state}).then(i=>{var g;return l=t.merge(i,(g=s())!=null?g:p),n(l,!0),h()}).then(()=>{m==null||m(l,void 0),l=s(),d=!0,S.forEach(i=>i(l))}).catch(i=>{m==null||m(void 0,i)})};return o.persist={setOptions:u=>{t={...t,...u},u.storage&&(c=u.storage)},clearStorage:()=>{c==null||c.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>v(),hasHydrated:()=>d,onHydrate:u=>(f.add(u),()=>{f.delete(u)}),onFinishHydration:u=>(S.add(u),()=>{S.delete(u)})},t.skipHydration||v(),l||p},de=(e,r)=>"getStorage"in r||"serialize"in r||"deserialize"in r?((ae?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),ce(e,r)):le(e,r),Se=de;export{me as c,Se as p};
