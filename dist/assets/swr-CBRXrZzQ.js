import{o as wt,r as p}from"./react-CxzTU07i.js";import{s as Gt}from"./use-sync-external-store-CdAcFHgC.js";const P=()=>{},C=P(),ut=Object,a=t=>t===C,y=t=>typeof t=="function",U=(t,e)=>({...t,...e}),Yt=t=>y(t.then),st=new WeakMap;let Xt=0;const Q=t=>{const e=typeof t,n=t&&t.constructor,o=n==Date;let s,i;if(ut(t)===t&&!o&&n!=RegExp){if(s=st.get(t),s)return s;if(s=++Xt+"~",st.set(t,s),n==Array){for(s="@",i=0;i<t.length;i++)s+=Q(t[i])+",";st.set(t,s)}if(n==ut){s="#";const c=ut.keys(t).sort();for(;!a(i=c.pop());)a(t[i])||(s+=i+":"+Q(t[i])+",");st.set(t,s)}}else s=o?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s},M=new WeakMap,lt={},ot={},vt="undefined",rt=typeof window!=vt,Rt=typeof document!=vt,Qt=()=>rt&&typeof window.requestAnimationFrame!=vt,Mt=(t,e)=>{const n=M.get(t);return[()=>!a(e)&&t.get(e)||lt,o=>{if(!a(e)){const s=t.get(e);e in ot||(ot[e]=s),n[5](e,U(s,o),s||lt)}},n[6],()=>!a(e)&&e in ot?ot[e]:!a(e)&&t.get(e)||lt]};let ht=!0;const Zt=()=>ht,[Tt,_t]=rt&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[P,P],te=()=>{const t=Rt&&document.visibilityState;return a(t)||t!=="hidden"},ee=t=>(Rt&&document.addEventListener("visibilitychange",t),Tt("focus",t),()=>{Rt&&document.removeEventListener("visibilitychange",t),_t("focus",t)}),ne=t=>{const e=()=>{ht=!0,t()},n=()=>{ht=!1};return Tt("online",e),Tt("offline",n),()=>{_t("online",e),_t("offline",n)}},se={isOnline:Zt,isVisible:te},oe={initFocus:ee,initReconnect:ne},Nt=!wt.useId,Z=!rt||"Deno"in window,re=t=>Qt()?window.requestAnimationFrame(t):setTimeout(t,1),ft=Z?p.useEffect:p.useLayoutEffect,dt=typeof navigator<"u"&&navigator.connection,yt=!Z&&dt&&(["slow-2g","2g"].includes(dt.effectiveType)||dt.saveData),Ot=t=>{if(y(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?Q(t):"",[t,e]};let ie=0;const mt=()=>++ie,xt=0,Pt=1,Ut=2,ae=3;var X={__proto__:null,ERROR_REVALIDATE_EVENT:ae,FOCUS_EVENT:xt,MUTATE_EVENT:Ut,RECONNECT_EVENT:Pt};async function qt(...t){const[e,n,o,s]=t,i=U({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let c=i.populateCache;const R=i.rollbackOnError;let d=i.optimisticData;const A=S=>typeof R=="function"?R(S):R!==!1,w=i.throwOnError;if(y(n)){const S=n,h=[],V=e.keys();for(const _ of V)!/^\$(inf|sub)\$/.test(_)&&S(e.get(_)._k)&&h.push(_);return Promise.all(h.map(T))}return T(n);async function T(S){const[h]=Ot(S);if(!h)return;const[V,_]=Mt(e,h),[it,r,tt,G]=M.get(e),x=()=>{const I=it[h];return(y(i.revalidate)?i.revalidate(V().data,S):i.revalidate!==!1)&&(delete tt[h],delete G[h],I&&I[0])?I[0](Ut).then(()=>V().data):V().data};if(t.length<3)return x();let v=o,D;const H=mt();r[h]=[H,0];const E=!a(d),$=V(),L=$.data,j=$._c,q=a(j)?L:j;if(E&&(d=y(d)?d(q,L):d,_({data:d,_c:q})),y(v))try{v=v(q)}catch(I){D=I}if(v&&Yt(v))if(v=await v.catch(I=>{D=I}),H!==r[h][0]){if(D)throw D;return v}else D&&E&&A(D)&&(c=!0,_({data:q,_c:C}));if(c&&!D)if(y(c)){const I=c(v,q);_({data:I,error:C,_c:C})}else _({data:v,error:C,_c:C});if(r[h][1]=mt(),Promise.resolve(x()).then(()=>{_({_c:C})}),D){if(w)throw D;return}return v}}const Ft=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},ce=(t,e)=>{if(!M.has(t)){const n=U(oe,e),o={},s=qt.bind(C,t);let i=P;const c={},R=(w,T)=>{const S=c[w]||[];return c[w]=S,S.push(T),()=>S.splice(S.indexOf(T),1)},d=(w,T,S)=>{t.set(w,T);const h=c[w];if(h)for(const V of h)V(T,S)},A=()=>{if(!M.has(t)&&(M.set(t,[o,{},{},{},s,d,R]),!Z)){const w=n.initFocus(setTimeout.bind(C,Ft.bind(C,o,xt))),T=n.initReconnect(setTimeout.bind(C,Ft.bind(C,o,Pt)));i=()=>{w&&w(),T&&T(),M.delete(t)}}};return A(),[t,s,A,i]}return[t,M.get(t)[4]]},ue=(t,e,n,o,s)=>{const i=n.errorRetryCount,c=s.retryCount,R=~~((Math.random()+.5)*(1<<(c<8?c:8)))*n.errorRetryInterval;!a(i)&&c>i||setTimeout(o,R,s)},le=(t,e)=>Q(t)==Q(e),[Ht,fe]=ce(new Map),de=U({onLoadingSlow:P,onSuccess:P,onError:P,onErrorRetry:ue,onDiscarded:P,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:yt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:yt?5e3:3e3,compare:le,isPaused:()=>!1,cache:Ht,mutate:fe,fallback:{}},se),Ee=(t,e)=>{const n=U(t,e);if(e){const{use:o,fallback:s}=t,{use:i,fallback:c}=e;o&&i&&(n.use=o.concat(i)),s&&c&&(n.fallback=U(s,c))}return n},Re=p.createContext({}),he="$inf$",$t=rt&&window.__SWR_DEVTOOLS_USE__,Te=$t?window.__SWR_DEVTOOLS_USE__:[],_e=()=>{$t&&(window.__SWR_DEVTOOLS_REACT__=wt)},jt=t=>y(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],me=()=>U(de,p.useContext(Re)),we=t=>(e,n,o)=>t(e,n&&((...i)=>{const[c]=Ot(e),[,,,R]=M.get(Ht);if(c.startsWith(he))return n(...i);const d=R[c];return a(d)?n(...i):(delete R[c],d)}),o),ve=Te.concat(we),Oe=t=>function(...n){const o=me(),[s,i,c]=jt(n),R=Ee(o,c);let d=t;const{use:A}=R,w=(A||[]).concat(ve);for(let T=w.length;T--;)d=w[T](d);return d(s,i||R.fetcher||null,R)},pe=(t,e,n)=>{const o=e[t]||(e[t]=[]);return o.push(n),()=>{const s=o.indexOf(n);s>=0&&(o[s]=o[o.length-1],o.pop())}},Se=(t,e)=>(...n)=>{const[o,s,i]=jt(n),c=(i.use||[]).concat(e);return t(o,s,{...i,use:c})};_e();const Wt=wt.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)}),Et={dedupe:!0},ge=(t,e,n)=>{const{cache:o,compare:s,suspense:i,fallbackData:c,revalidateOnMount:R,revalidateIfStale:d,refreshInterval:A,refreshWhenHidden:w,refreshWhenOffline:T,keepPreviousData:S}=n,[h,V,_,it]=M.get(o),[r,tt]=Ot(t),G=p.useRef(!1),x=p.useRef(!1),v=p.useRef(r),D=p.useRef(e),H=p.useRef(n),E=()=>H.current,$=()=>E().isVisible()&&E().isOnline(),[L,j,q,I]=Mt(o,r),k=p.useRef({}).current,kt=a(c)?n.fallback[r]:c,pt=(u,l)=>{for(const O in k){const f=O;if(f==="data"){if(!s(u[f],l[f])&&(!a(u[f])||!s(nt,l[f])))return!1}else if(l[f]!==u[f])return!1}return!0},St=p.useMemo(()=>{const u=!r||!e?!1:a(R)?E().isPaused()||i?!1:a(d)?!0:d:R,l=g=>{const F=U(g);return delete F._k,u?{isValidating:!0,isLoading:!0,...F}:F},O=L(),f=I(),N=l(O),K=O===f?N:l(f);let m=N;return[()=>{const g=l(L());return pt(g,m)?(m.data=g.data,m.isLoading=g.isLoading,m.isValidating=g.isValidating,m.error=g.error,m):(m=g,g)},()=>K]},[o,r]),z=Gt.useSyncExternalStore(p.useCallback(u=>q(r,(l,O)=>{pt(O,l)||u()}),[o,r]),St[0],St[1]),gt=!G.current,zt=h[r]&&h[r].length>0,B=z.data,J=a(B)?kt:B,et=z.error,Ct=p.useRef(J),nt=S?a(B)?Ct.current:B:J,Dt=zt&&!a(et)?!1:gt&&!a(R)?R:E().isPaused()?!1:i?a(J)?!1:d:a(J)||d,bt=!!(r&&e&&gt&&Dt),Bt=a(z.isValidating)?bt:z.isValidating,Jt=a(z.isLoading)?bt:z.isLoading,Y=p.useCallback(async u=>{const l=D.current;if(!r||!l||x.current||E().isPaused())return!1;let O,f,N=!0;const K=u||{},m=!_[r]||!K.dedupe,g=()=>Nt?!x.current&&r===v.current&&G.current:r===v.current,F={isValidating:!1,isLoading:!1},It=()=>{j(F)},Vt=()=>{const b=_[r];b&&b[1]===f&&delete _[r]},Lt={isValidating:!0};a(L().data)&&(Lt.isLoading=!0);try{if(m&&(j(Lt),n.loadingTimeout&&a(L().data)&&setTimeout(()=>{N&&g()&&E().onLoadingSlow(r,n)},n.loadingTimeout),_[r]=[l(tt),mt()]),[O,f]=_[r],O=await O,m&&setTimeout(Vt,n.dedupingInterval),!_[r]||_[r][1]!==f)return m&&g()&&E().onDiscarded(r),!1;F.error=C;const b=V[r];if(!a(b)&&(f<=b[0]||f<=b[1]||b[1]===0))return It(),m&&g()&&E().onDiscarded(r),!1;const W=L().data;F.data=s(W,O)?W:O,m&&g()&&E().onSuccess(O,r,n)}catch(b){Vt();const W=E(),{shouldRetryOnError:at}=W;W.isPaused()||(F.error=b,m&&g()&&(W.onError(b,r,W),(at===!0||y(at)&&at(b))&&(!E().revalidateOnFocus||!E().revalidateOnReconnect||$())&&W.onErrorRetry(b,r,W,Kt=>{const ct=h[r];ct&&ct[0]&&ct[0](X.ERROR_REVALIDATE_EVENT,Kt)},{retryCount:(K.retryCount||0)+1,dedupe:!0})))}return N=!1,It(),!0},[r,o]),At=p.useCallback((...u)=>qt(o,v.current,...u),[]);if(ft(()=>{D.current=e,H.current=n,a(B)||(Ct.current=B)}),ft(()=>{if(!r)return;const u=Y.bind(C,Et);let l=0;const f=pe(r,h,(N,K={})=>{if(N==X.FOCUS_EVENT){const m=Date.now();E().revalidateOnFocus&&m>l&&$()&&(l=m+E().focusThrottleInterval,u())}else if(N==X.RECONNECT_EVENT)E().revalidateOnReconnect&&$()&&u();else{if(N==X.MUTATE_EVENT)return Y();if(N==X.ERROR_REVALIDATE_EVENT)return Y(K)}});return x.current=!1,v.current=r,G.current=!0,j({_k:tt}),Dt&&(a(J)||Z?u():re(u)),()=>{x.current=!0,f()}},[r]),ft(()=>{let u;function l(){const f=y(A)?A(L().data):A;f&&u!==-1&&(u=setTimeout(O,f))}function O(){!L().error&&(w||E().isVisible())&&(T||E().isOnline())?Y(Et).then(l):l()}return l(),()=>{u&&(clearTimeout(u),u=-1)}},[A,w,T,r]),p.useDebugValue(nt),i&&a(J)&&r){if(!Nt&&Z)throw new Error("Fallback data is required when using suspense in SSR.");D.current=e,H.current=n,x.current=!1;const u=it[r];if(!a(u)){const l=At(u);Wt(l)}if(a(et)){const l=Y(Et);a(nt)||(l.status="fulfilled",l.value=!0),Wt(l)}else throw et}return{mutate:At,get data(){return k.data=!0,nt},get error(){return k.error=!0,et},get isValidating(){return k.isValidating=!0,Bt},get isLoading(){return k.isLoading=!0,Jt}}},Ce=Oe(ge),De=t=>(e,n,o)=>(o.revalidateOnFocus=!1,o.revalidateIfStale=!1,o.revalidateOnReconnect=!1,t(e,n,o)),Ie=Se(Ce,De);export{Ie as u};
